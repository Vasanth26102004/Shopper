"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resetSystemCACache = resetSystemCACache;
exports.mergeCA = mergeCA;
exports.removeCertificatesWithoutIssuer = removeCertificatesWithoutIssuer;
exports.systemCA = systemCA;
const system_ca_1 = require("system-ca");
const fs_1 = require("fs");
const tls_1 = require("tls");
const crypto_1 = require("crypto");
let systemCertsCachePromise;
function resetSystemCACache(systemCAOpts = {}) {
    systemCertsCachePromise = undefined;
    systemCertsCached(systemCAOpts).catch(() => undefined);
}
function systemCertsCached(systemCAOpts = {}) {
    if (systemCertsCachePromise)
        return systemCertsCachePromise;
    systemCertsCachePromise = (async () => {
        const certs = await (0, system_ca_1.systemCertsAsync)(systemCAOpts);
        return { certs, asyncFallbackError: systemCAOpts.asyncFallbackError };
    })();
    systemCertsCachePromise.catch(() => {
    });
    return systemCertsCachePromise;
}
function mergeCA(...args) {
    const ca = new Set();
    for (const item of args) {
        if (!item)
            continue;
        const caList = Array.isArray(item)
            ? item
            : [item];
        for (const cert of caList) {
            const asString = typeof cert === 'string'
                ? cert
                : Buffer.from(cert.buffer, cert.byteOffset, cert.byteLength).toString('utf8');
            ca.add(asString);
        }
    }
    return [...ca].join('\n');
}
const pemWithParsedCache = new WeakMap();
function removeCertificatesWithoutIssuer(ca) {
    let result = pemWithParsedCache.get(ca);
    const messages = [];
    let caWithParsedCerts = ca.map((pem) => {
        let parsed = null;
        try {
            parsed = new crypto_1.X509Certificate(pem);
        }
        catch (err) {
            messages.push(`Unable to parse certificate: ${err && typeof err === 'object' && 'message' in err
                ? String(err.message)
                : String(err)}`);
        }
        return { pem, parsed };
    });
    caWithParsedCerts = caWithParsedCerts.filter(({ parsed }) => {
        const keep = !parsed ||
            parsed.checkIssued(parsed) ||
            caWithParsedCerts.find(({ parsed: issuer }) => issuer && parsed.checkIssued(issuer));
        if (!keep) {
            messages.push(`Removing certificate for '${parsed.subject}' because issuer '${parsed.issuer}' could not be found (serial no '${parsed.serialNumber}')`);
        }
        return keep;
    });
    result = { ca: caWithParsedCerts.map(({ pem }) => pem), messages };
    pemWithParsedCache.set(ca, result);
    return result;
}
async function systemCA(existingOptions = {}, allowCertificatesWithoutIssuer) {
    let readTLSCAFilePromise;
    if (existingOptions.tlsCAFile) {
        readTLSCAFilePromise = fs_1.promises.readFile(existingOptions.tlsCAFile, 'utf8');
        readTLSCAFilePromise.catch(() => {
        });
    }
    let systemCertsError;
    let asyncFallbackError;
    let systemCerts = [];
    let messages = [];
    try {
        ({ certs: systemCerts, asyncFallbackError } = await systemCertsCached());
    }
    catch (err) {
        systemCertsError = err;
    }
    if (!(allowCertificatesWithoutIssuer ??
        !!process.env.DEVTOOLS_ALLOW_CERTIFICATES_WITHOUT_ISSUER)) {
        const reducedList = removeCertificatesWithoutIssuer(systemCerts);
        systemCerts = reducedList.ca;
        messages = messages.concat(reducedList.messages);
    }
    return {
        ca: mergeCA(systemCerts, tls_1.rootCertificates, existingOptions.ca, await readTLSCAFilePromise),
        asyncFallbackError: asyncFallbackError,
        systemCertsError,
        systemCACount: systemCerts.length + tls_1.rootCertificates.length,
        messages,
    };
}
//# sourceMappingURL=system-ca.js.map